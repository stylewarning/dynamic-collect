;;;; dynamic-collect.lisp
;;;; Copyright (c) 2013 Robert Smith

(in-package #:dynamic-collect)

(defvar *ensure-handled-collect* nil
  "If T, ensure that COLLECT forms are inside
  WITH-DYNAMIC-COLLECTION. If NIL, return the specified RETURN value
  from COLLECT.")

(define-condition messenger (condition)
  ((payload :initarg :payload
            :reader messenger-payload)
   
   ;; CONTINUEP denotes whether or not the value should be collected
   ;; and then computation after a COLLECT form should continue.
   (continuep :initarg :continuep
              :initform t
              :reader messenger-continuep
              :type boolean)
   
   ;; The ID is used to make sure only the proper and correct continue
   ;; restart is found.
   (id        :initarg :id
              :reader messenger-id
              :type symbol)
   
   ;; The TAG is used to match up the messenger from a COLLECT to the
   ;; right WITH-DYNAMIC-COLLECTION form.
   (tag       :initarg :tag
              :initform nil
              :reader messenger-tag))
  (:documentation "A condition to carry messages between parts of programs.")
  (:report (lambda (condition stream)
             (declare (ignore condition))
             (format stream
                     "~A was used outside of a ~A form."
                     'collect
                     'with-dynamic-collection))))

(defun collect (data &key return
                          (continuep t)
                          tag)
  "Collect the data DATA in a WITH-DYNAMIC-COLLECTION
environment. Return the value RETURN from the form in the event the
function is returned from.

If CONTINUEP is null, then collecting will cease and the
matching WITH-DYNAMIC-COLLECTION form will return.

The TAG denotes at which WITH-DYNAMIC-COLLECTION form the DATA will be
accumulated."
  (let ((id (gensym "ID-")))
    (restart-case (let ((messenger (make-condition 'messenger
                                                   :payload data
                                                   :continuep continuep
                                                   :id id
                                                   :tag tag)))
                    
                    (if *ensure-handled-collect*
                        (error messenger)
                        (or (signal messenger)
                            return)))
      (continue ()
        :report (lambda (stream)
                  (format stream
                          "Return from ~A with ~S."
                          'collect
                          return))
        ;; We only want this restart available to MESSENGER
        ;; conditions. We also only want this restart available to
        ;; conditions generated by the same messenger that was
        ;; signalled.
        :test (lambda (condition)
                (and (typep condition 'messenger)
                     (eq id (messenger-id condition))))
        return))))

(defmacro with-dynamic-collection ((&key tag) &body body)
  "Dynamically collect messages that were signalled during the
execution of BODY from COLLECT. Return a list of messages in the order
they were collected. If TAG is provided, then only COLLECT forms which
have the same tag will be accrued."
  (let ((messages (gensym "MESSAGES-"))
        (block-name (gensym "BLOCK-NAME-"))
        (tag-once (gensym "TAG-ONCE-")))
    `(let ((,messages nil)
           (,tag-once ,tag))
       (block ,block-name
         (handler-bind
             ((messenger (lambda (m)
                           (when (eql ,tag-once (messenger-tag m))
                             (push (messenger-payload m) ,messages)
                             (if (messenger-continuep m)
                                 (invoke-restart (find-restart 'continue m))
                                 (return-from ,block-name
                                   (nreverse ,messages)))))))
           ,@body)
         (nreverse ,messages)))))
