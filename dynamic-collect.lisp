;;;; dynamic-collect.lisp
;;;; Copyright (c) 2013 Robert Smith

(in-package #:dynamic-collect)

(defvar *ensure-handled-collect* nil
  "If T, ensure that COLLECT forms are inside
  WITH-DYNAMIC-COLLECTION. If NIL, simply return NIL from bla.")

(define-condition messenger (condition)
  ((payload :initarg :payload
            :reader messenger-payload)
   (continuep :initarg :continuep
              :initform t
              :reader messenger-continuep)
   (id        :initarg :id
              :reader messenger-id))
  (:documentation "A condition to carry messages between parts of programs.")
  (:report (lambda (condition stream)
             (declare (ignore condition))
             (format stream
                     "~A was used outside of a ~A form."
                     'collect
                     'with-dynamic-collection))))

(defun collect (data &key return
                          (continuep t)
                     &aux (id (gensym "ID-")))
  "Collect the data DATA in a WITH-DYNAMIC-COLLECTION
environment. Optionally return the value RETURN from the
form. If CONTINUEP is null, then collecting will cease and the
WITH-DYNAMIC-COLLECTION form will return."
  (restart-case (if *ensure-handled-collect*
                    (error 'messenger :payload data
                                      :continuep continuep
                                      :id id)
                    (or (signal 'messenger :payload data
                                           :continuep continuep
                                           :id id)
                        return))
    (continue ()
      :report (lambda (stream)
                (format stream
                        "Return from ~A with ~S."
                        'collect
                        return))
      ;; We only want this restart available to MESSENGER
      ;; conditions. We also only want this restart available to
      ;; conditions generated by the same messenger that was
      ;; signalled.
      :test (lambda (condition)
              (and (typep condition 'messenger)
                   (eq id (messenger-id condition))))
      return)))

(defmacro with-dynamic-collection (&body body)
  "Dynamically collect messages that were signalled during the
execution of BODY from ACCRUE. Return a list of messages in the order
they were collected."
  (let ((messages (gensym "MESSAGES-"))
        (block-name (gensym "BLOCK-NAME-")))
    `(let ((,messages nil))
       (block ,block-name
         (handler-bind
             ((messenger (lambda (m)
                           (push (messenger-payload m) ,messages)
                           (if (messenger-continuep m)
                               (invoke-restart 'continue)
                               (return-from ,block-name
                                 (nreverse ,messages))))))
           ,@body)
         (nreverse ,messages)))))
